# Exploitability Validation & Exploit Feasibility Integration

This document explains how RAPTOR's two validation systems work together to ensure vulnerability findings are both **real** and **exploitable**.

## The Problem

Security scanners and LLM-based analysis can produce findings that:
1. **Don't exist** - Hallucinated files, functions, or code
2. **Aren't reachable** - Dead code, test files, unrealistic preconditions
3. **Can't be exploited** - System mitigations block all viable techniques

Investing in exploit development for any of these wastes significant time.

## Two Validation Layers

### Layer 1: Exploitability Validation (Source-Level)

**Question answered:** "Is this finding REAL and REACHABLE?"

| Aspect | Details |
|--------|---------|
| **Input** | Source code + scanner findings |
| **Validates** | File exists, code accurate, flow real, not test code |
| **Output** | Validated findings with working PoCs |
| **Location** | `.claude/skills/exploitability-validation/` |

**Stages:**
1. **Inventory** - Build checklist of all code to analyze
2. **One-Shot** - Quick exploitability verification + PoC
3. **Process** - Systematic analysis with attack trees
4. **Sanity** - Verify against actual code (catch hallucinations)
5. **Ruling** - Filter test code, preconditions, hedging language
6. **Feasibility** - Binary constraint analysis (memory corruption only, auto-bridges to exploit_feasibility)

### Layer 2: Exploit Feasibility (Binary-Level)

**Question answered:** "CAN this be exploited given system mitigations?"

| Aspect | Details |
|--------|---------|
| **Input** | Compiled binary |
| **Validates** | PIE, NX, Canary, RELRO, glibc version, ROP gadgets, bad bytes |
| **Output** | Verdict (Exploitable/Likely/Difficult/Unlikely/Unknown) + chain breaks |
| **Location** | `packages/exploit_feasibility/` |

**Checks:**
- Binary protections (PIE, NX, Stack Canary, RELRO)
- Glibc mitigations (removed hooks, %n blocking, safe linking)
- Input handler constraints (null bytes, bad characters)
- ROP gadget availability and quality
- Empirical verification (actually tests %n, not just version checks)
- Kernel mitigations (ASLR level, ptrace scope, etc.)

## How They Work Together

```
┌─────────────────────────────────────────────────────────────────────────────┐
│  SCANNER (Semgrep/CodeQL)                                                   │
│  "Found potential command injection in utils/shell.py:42"                   │
└─────────────────────────────────┬───────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  EXPLOITABILITY VALIDATION - Stages 0-D (Source-Level)                      │
│                                                                             │
│  Stage 0: Inventory - enumerate all functions                               │
│  Stage A: One-shot - quick PoC attempt                                      │
│  Stage B: Process - attack trees, hypotheses, feasibility init              │
│           → validates attack_path_ref references                            │
│           → tags chain_breaks with [source] prefix                          │
│  Stage C: Sanity - file exists? code verbatim? flow real?                   │
│  Stage D: Ruling - not test code? no unrealistic preconditions?             │
│           → sets final_status for all findings                              │
│                                                                             │
│  Schema validation gates at each stage boundary                             │
│                                                                             │
│  RESULT: "Validated. Real vulnerability, reachable, PoC works."             │
└─────────────────────────────────┬───────────────────────────────────────────┘
                                  │
                      ┌───────────┴───────────┐
                      │                       │
                      ▼                       ▼
              Memory Corruption         Web/Injection
              (buffer overflow,         (command injection,
               format string, UAF)       SQL injection, XSS)
                      │                       │
                      ▼                       │
┌─────────────────────────────────────────┐   │
│  STAGE E: EXPLOIT FEASIBILITY           │   │
│  (Automatic bridge to exploit_feasibility)  │
│                                         │   │
│  Analyze binary constraints:            │   │
│  - Full RELRO? → GOT blocked            │   │
│  - glibc 2.38? → %n blocked             │   │
│  - strcpy? → null bytes block ROP       │   │
│  - Unknown glibc? → empirical %n test   │   │
│  - No checksec? → verdict UNKNOWN       │   │
│                                         │   │
│  RESULT: verdict + chain_breaks +       │   │
│    what_would_help + binary_analysis +  │   │
│    context_file (relative path)         │   │
│                                         │   │
│  Source chain_breaks merged with binary  │   │
│  breaks (tagged [source]/[binary])      │   │
└─────────────────────┬───────────────────┘   │
                      │                       │
                      └───────────┬───────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  FINAL OUTPUT (final_status values)                                        │
│                                                                             │
│  exploitable:           Confirmed exploitable, standard techniques work     │
│  likely_exploitable:    Viable paths exist with some constraints            │
│  confirmed_constrained: Primitives exist but hard to chain (Difficult)      │
│  confirmed_blocked:     No viable path with current mitigations (Unlikely)  │
│  confirmed_unverified:  Analysis incomplete (no binary, error, unknown)     │
│  confirmed:             Web vuln (Stage E not applicable)                   │
│  ruled_out:             Failed sanity/ruling checks                         │
└─────────────────────────────────┬───────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│  LLM ANALYSIS / EXPLOIT DEVELOPMENT                                        │
│                                                                             │
│  Agent filtering:                                                           │
│  - Skips: ruled_out, disproven, confirmed_blocked, unlikely verdict         │
│  - Checks both 'status' and 'final_status' for exclusion                   │
│  - Missing final_status defaults to 'pending'                              │
│  - level='error' for exploitable/likely_exploitable/confirmed_constrained  │
│  - level='warning' for everything else                                     │
│                                                                             │
│  feasibility.binary_analysis contains full analysis data:                  │
│  protections, exploitation_paths, rop_gadgets, constraints, etc.           │
└─────────────────────────────────────────────────────────────────────────────┘
```

## When Each Layer Applies

| Vulnerability Type | Exploitability Validation | Exploit Feasibility |
|-------------------|---------------------------|---------------------|
| Command Injection | Yes | No (not memory corruption) |
| SQL Injection | Yes | No |
| XSS | Yes | No |
| Path Traversal | Yes | No |
| Buffer Overflow | Yes | **Yes** |
| Format String | Yes | **Yes** |
| Use-After-Free | Yes | **Yes** |
| Heap Overflow | Yes | **Yes** |

## Verdict Mapping

The exploit_feasibility `ExploitabilityVerdict` enum maps to `final_status` as follows:

| Verdict | final_status | Meaning |
|---------|-------------|---------|
| `exploitable` | `exploitable` | Standard techniques should work |
| `likely_exploitable` | `likely_exploitable` | Viable paths exist with some constraints |
| `difficult` | `confirmed_constrained` | Possible but requires advanced techniques |
| `unlikely` | `confirmed_blocked` | No known viable path given mitigations |
| `unknown` | `confirmed_unverified` | Insufficient data (no binary, checksec failed) |
| `error` | `confirmed_unverified` | Analysis failed (error details in feasibility) |

For non-memory-corruption findings, `_derive_verdict_from_source` derives verdicts from source-level analysis:
- Both `chain_breaks` and `what_would_help` → `difficult`
- `chain_breaks` only → `unlikely`
- `what_would_help` only → `difficult` (unknowns remain)
- Neither → `likely_exploitable`

## API Integration

### Automatic (via Stage E)

Stage E automatically handles the integration for memory corruption vulnerabilities:

```python
# Stage E does this automatically - see stage-e-feasibility.md

from packages.exploit_feasibility import (
    analyze_binary,
    save_exploit_context
)

for finding in confirmed_memory_corruption_findings:
    result = analyze_binary(binary_path, vuln_type=finding['vuln_type'])
    context_file = save_exploit_context(binary_path)

    # Error detection
    is_error = result.get('verdict') == 'error' or result.get('error')

    # Full analysis data preserved in binary_analysis
    finding['feasibility'] = {
        'status': 'error' if is_error else 'analyzed',
        'verdict': result['verdict'],
        'chain_breaks': [...],       # Tagged [source]/[binary]
        'what_would_help': [...],    # Merged source + binary suggestions
        'binary_analysis': {         # Full result preserved
            'protections': {...},
            'exploitation_paths': {...},
            'rop_gadgets': {...},
            'constraints': {...},
            'glibc_mitigations': {...},
            ...
        },
        'context_file': 'relative/path/to/context.json',
    }

    # Verdict → final_status (explicit for all values)
    finding['final_status'] = {
        'exploitable': 'exploitable',
        'likely_exploitable': 'likely_exploitable',
        'difficult': 'confirmed_constrained',
        'unlikely': 'confirmed_blocked',
        'unknown': 'confirmed_unverified',
        'error': 'confirmed_unverified',
    }.get(result['verdict'], 'confirmed_unverified')
```

### Manual / Standalone

```python
from packages.exploit_feasibility import analyze_binary, format_analysis_summary

# Full analysis
result = analyze_binary('/path/to/binary')
print(format_analysis_summary(result, verbose=True))

# Quick viability check
from packages.exploit_feasibility import check_exploit_viability
viable, reason = check_exploit_viability('/path/to/binary', 'format_string')

# Context persistence (for later use after compaction)
from packages.exploit_feasibility import save_exploit_context, load_exploit_context
context_file = save_exploit_context('/path/to/binary')
ctx = load_exploit_context(context_file)
```

## Data Model

### FeasibilityReport.glibc_n_disabled

Type: `Optional[bool]` (not `bool`)

| Value | Meaning |
|-------|---------|
| `None` | Unknown — glibc detection failed, empirical test may resolve |
| `True` | Confirmed disabled (glibc >= 2.38 or empirical test failed) |
| `False` | Confirmed working (empirical test passed) |

When glibc detection fails (containers, minimal images), the empirical `%n` test is automatically attempted on local targets. Remote targets conservatively assume `True` (disabled).

### Chain Breaks Tagging

Merged `chain_breaks` are prefixed to distinguish their source:
- `[source] WAF blocks single quotes` — from source-level analysis (Stage B)
- `[binary] Full RELRO blocks GOT overwrite` — from binary analysis (Stage E)

This prevents contradictions (e.g., "overflow possible" from source + "canary blocks overflow" from binary) from being ambiguous.

## Validation Gates

### Schema Validation at Stage Boundaries

Each stage validates that findings have required fields before processing:

| Stage | Required Fields |
|-------|----------------|
| B | id, vuln_type, status (must be "not_disproven") |
| C | id, file, function, line |
| D | id, vuln_type |
| E | id, vuln_type |

Validation is non-blocking (logs warnings) to prevent pipeline failures from minor schema issues.

### MUST-GATEs (Validation Rigor)

| Gate | Rule | Prevents |
|------|------|----------|
| GATE-1 | Assume exploitable until proven otherwise | Premature dismissal |
| GATE-2 | Strict sequence, additional ideas separate | Methodology drift |
| GATE-3 | Track checklist compliance | Incomplete coverage |
| GATE-4 | Verify all "if/maybe/uncertain" claims | Unverified hedging |
| GATE-5 | Check ALL code, no sampling | Missed vulnerabilities |
| GATE-6 | Show proof for every finding | Hallucinations |

### Attack Path Reference Validation

Stage B validates that all `attack_path_ref` values (e.g., `"attack-paths.json#PATH-001"`) resolve to actual entries in attack-paths.json. Dangling references are logged as warnings.

### SARIF Deduplication

SARIF ingestion deduplicates findings on `(file, line, normalized_vuln_type)`. Cross-tool duplicates (e.g., Semgrep + CodeQL finding the same vuln) produce a single finding with the first tool's metadata.

## Output Files

### Exploitability Validation

```
.out/exploitability-validation-<timestamp>/
├── checklist.json           # Ground truth: all functions to check
├── findings.json            # Validated findings with PoCs + feasibility
├── attack-tree.json         # Knowledge graph of attack surface
├── hypotheses.json          # Tested exploitation hypotheses
├── disproven.json           # Failed approaches (learning)
├── attack-paths.json        # Paths tried + PROXIMITY tracking
├── attack-surface.json      # Sources, sinks, trust boundaries
└── validation-report.md     # Human-readable summary
```

### Exploit Feasibility

```
.out/exploit-context-<binary>-<timestamp>.json
├── binary_info              # Path, arch, protections
├── libc                     # Version, offsets, mitigations
├── gadgets                  # ROP gadget analysis
├── constraints              # Input handler bad bytes
├── verdict                  # Exploitable/Likely/Difficult/Unlikely/Unknown
├── chain_breaks             # What techniques are blocked
└── what_would_help          # Suggestions for success
```

## Command Integration

```bash
# Full pipeline: scan -> validate -> exploit
/scan ./webapp                     # Find potential vulns
/validate ./webapp                 # Confirm they're real
/exploit ./webapp --finding FIND-001  # Develop working exploit

# With binary for feasibility analysis
/validate ./webapp --binary ./build/webapp

# With specific vulnerability type
/validate ./webapp --vuln-type command_injection

# Validate existing findings
/validate ./webapp --findings scanner-results.json
```

## Benefits of Dual Validation

1. **No wasted effort on hallucinations** - Stage C catches fabricated findings
2. **No wasted effort on unreachable code** - Stage D filters test/dead code
3. **No wasted effort on impossible exploits** - Feasibility catches blocked techniques
4. **Clear guidance on what WILL work** - Both systems provide actionable paths forward
5. **Documented learning** - disproven.json and chain_breaks explain what was tried
6. **Full analysis preserved** - binary_analysis field retains all feasibility data for exploit development

## Summary

| Layer | Question | When | Output |
|-------|----------|------|--------|
| Exploitability Validation | Is it REAL? | All findings | Validated + PoC |
| Exploit Feasibility | Can we EXPLOIT it? | Memory corruption | Verdict + constraints + full analysis |

Together, they ensure you only invest exploit development time on vulnerabilities that are both **confirmed real** and **actually exploitable**.
